#include "test.h"
#include "sm4_bs256.h"
#include "utils.h"

void sm4_bs256_ecb_test()
{
    uint8_t key_vector[16] = {0x01, 0x23, 0x45, 0x67, 0x89, 0xab, 0xcd, 0xef, 0xfe, 0xdc, 0xba, 0x98, 0x76, 0x54, 0x32, 0x10};
    //uint8_t pt_vector[16] =  {0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};
    uint8_t pt_vector[16] =  {0x01, 0x23, 0x45, 0x67, 0x89, 0xab, 0xcd, 0xef, 0xfe, 0xdc, 0xba, 0x98, 0x76, 0x54, 0x32, 0x10};
    uint8_t ct_vector[16] =  {0x68, 0x1e, 0xdf, 0x34, 0xd2, 0x06, 0x96, 0x5e, 0x86, 0xb3, 0xe9, 0x4f, 0x53, 0x6e, 0x42, 0x46};
    uint8_t output[16];
    uint8_t input[16];
    __m256i rk[32][32];

    sm4_bs256_key_schedule(key_vector,rk);
    printf("SM4_BS256 ECB 1 block Accuracy Test.:\n");
    sm4_bs256_ecb_encrypt(output,pt_vector,16,rk);
    printf("cipher text: \n");
    dump_hex(output,16);
    if(memcmp(ct_vector,output,16)==0)
        printf("SM4_BS256 ECB 1 block encrypt Test passed!\n");
    printf("SM4_BS256 ECB 1 block Accuracy Test end:\n\n");

    // printf("SM4 ECB 4 block Accuracy Test.:\n");
    // uint8_t out[64];
    // uint8_t pt[64] =  {0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0A, 0x0B, 0x00, 0x00, 0x00, 0x00,
    //                     0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0A, 0x0B, 0x00, 0x00, 0x00, 0x01,
    //                     0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0A, 0x0B, 0x00, 0x00, 0x00, 0x02,
    //                     0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0A, 0x0B, 0x00, 0x00, 0x00, 0x03};
    // // uint8_t pt[64] = {
    // //     0x01, 0x23, 0x45, 0x67, 0x89, 0xab, 0xcd, 0xef, 0xfe, 0xdc, 0xba, 0x98, 0x76, 0x54, 0x32, 0x10,
	// // 	0x01, 0x23, 0x45, 0x67, 0x89, 0xab, 0xcd, 0xef, 0xfe, 0xdc, 0xba, 0x98, 0x76, 0x54, 0x32, 0x10,
	// // 	0x01, 0x23, 0x45, 0x67, 0x89, 0xab, 0xcd, 0xef, 0xfe, 0xdc, 0xba, 0x98, 0x76, 0x54, 0x32, 0x10,
	// // 	0x01, 0x23, 0x45, 0x67, 0x89, 0xab, 0xcd, 0xef, 0xfe, 0xdc, 0xba, 0x98, 0x76, 0x54, 0x32, 0x10
    // // };
    // sm4_bs256_ecb_encrypt(out,pt,64,rk);
    // printf("cipher text: \n");
    // dump_hex(out,64);
    // printf("SM4 ECB 4 block Accuracy Test end:\n\n");


    //uint8_t plain[16*256];
    uint8_t plain[256*256];
    uint8_t *p = (uint8_t *)plain;
    uint8_t out_plain[16*256];
    for(int i=0; i<256; i++)
    {
        memcpy(p,pt_vector,16);
        p += 16;
    }

    printf("SM4-AVX2-bitslice ECB Speed Test:\n");
    uint8_t *plainn = (uint8_t *)malloc(16*(1<<15));
    uint8_t *c = plainn;
    benchmark_sm4_bs_ecb_encrypt(plainn,c,1*16,rk);
    benchmark_sm4_bs_ecb_encrypt(plainn,c,4*16,rk);
    benchmark_sm4_bs_ecb_encrypt(plainn,c,256,rk);
    benchmark_sm4_bs_ecb_encrypt(plainn,c,1024,rk);
    benchmark_sm4_bs_ecb_encrypt(plainn,c,8192,rk);
    benchmark_sm4_bs_ecb_encrypt(plainn,c,16384,rk);
    printf("SM4-AVX2-bitslice ECB Speed Test end!\n");
    
}


void sm4_bs256_ctr_test()
{       
    #define SM4_CTR_TESTS_BYTES 64
    //printf("SM4 CTR 4 block:\n");
    //test vector from https://tools.ietf.org/id/draft-ribose-cfrg-sm4-09.html#rfc.appendix.A.2.5
    //Example1 Key:
    uint8_t key_vector[16] =
        {0x01, 0x23, 0x45, 0x67, 0x89, 0xAB, 0xCD, 0xEF, 0xFE, 0xDC, 0xBA, 0x98, 0x76, 0x54, 0x32, 0x10};
    uint8_t iv_vector[16]  =
        {0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F};
    uint8_t pt_vector[SM4_CTR_TESTS_BYTES] =
        {0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xBB,0xBB,0xBB,0xBB,0xBB,0xBB,0xBB,0xBB,
            0xCC,0xCC,0xCC,0xCC,0xCC,0xCC,0xCC,0xCC,0xDD,0xDD,0xDD,0xDD,0xDD,0xDD,0xDD,0xDD,
            0xEE,0xEE,0xEE,0xEE,0xEE,0xEE,0xEE,0xEE,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,
            0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xBB,0xBB,0xBB,0xBB,0xBB,0xBB,0xBB,0xBB};
    uint8_t ct_vector[SM4_CTR_TESTS_BYTES] =
       {0xAC, 0x32, 0x36, 0xCB, 0x97, 0x0C, 0xC2, 0x07, 0x91, 0x36, 0x4C, 0x39, 0x5A, 0x13, 0x42, 0xD1,
        0xA3, 0xCB, 0xC1, 0x87, 0x8C, 0x6F, 0x30, 0xCD, 0x07, 0x4C, 0xCE, 0x38, 0x5C, 0xDD, 0x70, 0xC7,
        0xF2, 0x34, 0xBC, 0x0E, 0x24, 0xC1, 0x19, 0x80, 0xFD, 0x12, 0x86, 0x31, 0x0C, 0xE3, 0x7B, 0x92,
        0x6E, 0x02, 0xFC, 0xD0, 0xFA, 0xA0, 0xBA, 0xF3, 0x8B, 0x29, 0x33, 0x85, 0x1D, 0x82, 0x45, 0x14};

    //Example2 Key:
    // uint8_t key_vector[16] =
    //     {0xFE, 0xDC, 0xBA, 0x98, 0x76, 0x54, 0x32, 0x10, 0x01, 0x23, 0x45, 0x67, 0x89, 0xAB, 0xCD, 0xEF };
    // uint8_t iv_vector[16]  =
    //     {0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0A, 0x0B, 0x00, 0x00, 0x00, 0x00};
    // uint8_t key_vector[16] =
    // {   
    //     0x00,0x01,0x00,0x02,0x00,0x03,0x00,0x04,
    //     0x00,0x05,0x00,0x06,0x00,0x07,0x00,0x08
    // };
    // uint8_t iv_vector[16]  =
    //     {0x5c,0x36,0x5c,0x36,0x5c,0x36,0x5c,0x36,0x5c,0x36,0x5c,0x36,0x00, 0x00, 0x00, 0x00};
    // uint8_t pt_vector[SM4_CTR_TESTS_BYTES] = {
    //     0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    //     0x08,0x06,0x00,0x01,0x08,0x00,0x06,0x04,0x00,0x01,0x00,0x03,0x7f,0xff,0xff,0xfe,
    //     0xc0,0xa8,0x14,0x0a,0x00,0x00,0x00,0x00,0x00,0x00,0xc0,0xa8,0x14,0x0d,0x00,0x00,
    //     0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    // };

    uint8_t output[SM4_CTR_TESTS_BYTES];
    uint8_t input[SM4_CTR_TESTS_BYTES];
    uint8_t t[SM4_CTR_TESTS_BYTES];
    __m256i rk[32][32];

    sm4_bs256_key_schedule(key_vector,rk);

    sm4_bs256_ctr_encrypt(output,pt_vector,SM4_CTR_TESTS_BYTES,rk, iv_vector);
    printf("ciphertext: \n");
    dump_hex(output,SM4_CTR_TESTS_BYTES);

    sm4_bs256_ctr_encrypt(t,output,SM4_CTR_TESTS_BYTES,rk, iv_vector);
    printf("plaintext: \n");
    dump_hex(t,SM4_CTR_TESTS_BYTES);

    printf("SM4-AVX2-bitslice CTR Speed Test.\n");
    uint8_t *plainn = (uint8_t *)malloc(16*(1<<15));
    uint8_t *c = plainn;
    benchmark_sm4_bs_ctr_encrypt(plainn,c,1*16,rk,iv_vector);
    benchmark_sm4_bs_ctr_encrypt(plainn,c,4*16,rk,iv_vector);
    benchmark_sm4_bs_ctr_encrypt(plainn,c,16*16,rk,iv_vector);
    benchmark_sm4_bs_ctr_encrypt(plainn,c,1024,rk,iv_vector);
    benchmark_sm4_bs_ctr_encrypt(plainn,c,4096,rk,iv_vector);
    benchmark_sm4_bs_ctr_encrypt(plainn,c,8192,rk,iv_vector);
    benchmark_sm4_bs_ctr_encrypt(plainn,c,16384,rk,iv_vector);
    printf("SM4-AVX2-bitslice CTR Speed Test end!\n\n");

}

void sm4_bs256_gcm_test()
{       
    // printf("SM4 GCM 256 block:\n");
    // //tect vector from ant finanical 
    // //https://tools.ietf.org/id/draft-yang-tls-tls13-sm-suites-03.html#rfc.appendix.A.1
    // uint8_t iv[12] = {0x00,0x00,0x12,0x34,0x56,0x78,0x00,0x00,0x00,0x00,0xAB,0xCD};
    // uint8_t key[16] = {0x01, 0x23, 0x45, 0x67, 0x89, 0xab, 0xcd, 0xef, 0xfe, 0xdc, 0xba, 0x98, 0x76, 0x54, 0x32, 0x10};
    // uint8_t pt[64] = {0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xBB,0xBB,0xBB,0xBB,0xBB,0xBB,0xBB,0xBB,
    //             0xCC,0xCC,0xCC,0xCC,0xCC,0xCC,0xCC,0xCC,0xDD,0xDD,0xDD,0xDD,0xDD,0xDD,0xDD,0xDD,
    //             0xEE,0xEE,0xEE,0xEE,0xEE,0xEE,0xEE,0xEE,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,
    //             0xEE,0xEE,0xEE,0xEE,0xEE,0xEE,0xEE,0xEE,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA};
    // uint8_t Associated_Data[20] = {0xFE,0xED,0xFA,0xCE,0xDE,0xAD,0xBE,0xEF,0xFE,0xED,0xFA,0xCE,
    //                         0xDE,0xAD,0xBE,0xEF,0xAB,0xAD,0xDA,0xD2};
    // uint8_t ct[64] = {0x48,0xAF,0x93,0x50,0x1F,0xA6,0x2A,0xDB,0xCD,0x41,0x4C,0xCE,0x60,0x34,0xD8,0x95,
    //             0xDD,0xA1,0xBF,0x8F,0x13,0x2F,0x04,0x20,0x98,0x66,0x15,0x72,0xE7,0x48,0x30,0x94,
    //             0xFD,0x12,0xE5,0x18,0xCE,0x06,0x2C,0x98,0xAC,0xEE,0x28,0xD9,0x5D,0xF4,0x41,0x6B,
    //             0xED,0x31,0xA2,0xF0,0x44,0x76,0xC1,0x8B,0xB4,0x0C,0x84,0xA7,0x4B,0x97,0xDC,0x5B};
    // uint8_t au_tag[16] = {0x16,0x84,0x2D,0x4F,0xA1,0x86,0xF5,0x6A,0xB3,0x32,0x56,0x97,0x1F,0xA1,0x10,0xF4};
    #define SM4_GCM_TESTS_BYTES 48
    printf("SM4_BS256 GCM 4 block:\n");
    //http://www.gmbz.org.cn/file/2018-01-10/384aaf7c-7530-4290-b314-24264065db9e.pdf
    //tect vector from GB/T 36624--2018:C.5 可鉴别的加密机制5
    // uint8_t key_vector[16] =
    //     {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };
    // uint8_t iv_vector[16]  =
    //     {0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};
    // uint8_t pt_vector[SM4_GCM_TESTS_BYTES] =
    //     {0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    //     0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    //     0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};

    //tect vector from GB/T 0042--2015 三元对等密码安全协议测试规范
    uint8_t key_vector[16] =
    {   
        0x00,0x01,0x00,0x02,0x00,0x03,0x00,0x04,
        0x00,0x05,0x00,0x06,0x00,0x07,0x00,0x08
    };
    uint8_t iv_vector[16]  =
        {0x5c,0x36,0x5c,0x36,0x5c,0x36,0x5c,0x36,0x5c,0x36,0x5c,0x36,0x00, 0x00, 0x00, 0x00};

    uint8_t Associated_Data[]={
        0xff,0xff,0xff,0xff,0xff,0xff,0x00,0x03,0x7f,0xff,0xff,0xfe,0x89,0x2c,0x38,0x00,
        0x00,0x5c,0x36,0x5c,0x36,0x5c,0x36
    };
    uint8_t pt_vector[SM4_GCM_TESTS_BYTES] =
        {0x08,0x06,0x00,0x01,0x08,0x00,0x06,0x04,0x00,0x01,0x00,0x03,0x7f,0xff,0xff,0xfe,
        0xc0,0xa8,0x14,0x0a,0x00,0x00,0x00,0x00,0x00,0x00,0xc0,0xa8,0x14,0x0d,0x00,0x00,
        0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};
    uint8_t ct_vector[SM4_GCM_TESTS_BYTES] =
       {0x0a,0x59,0x91,0xa6,0x70,0xdc,0x0e,0xa2,0x6f,0x84,0xe4,0x55,0xa1,0xc0,0x61,0x47,
        0x8a,0xa0,0x9f,0x2f,0xbe,0x90,0x49,0x46,0x29,0xbc,0x58,0xe7,0x5b,0xe5,0xe9,0x1d,
        0xbc,0x6d,0x21,0x49,0xbc,0x1f,0xba,0xca,0xca,0xa9,0x72,0x2d,0x61,0x0f,0xde,0x1d};
    uint8_t tag[16] = {0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};
    uint8_t T[16][256][16];

    uint8_t output[SM4_GCM_TESTS_BYTES];
    uint8_t input[SM4_GCM_TESTS_BYTES];
    uint8_t t[SM4_GCM_TESTS_BYTES];
    __m256i rk[32][32];

    //sm4_bs256_key_schedule(key_vector,rk);

    gcm_context *ctx = gcm_init();
    sm4_bs256_gcm_init(ctx,key_vector,rk,iv_vector);

    printf("ctx->: \n");
    dump_hex(tag,sizeof(tag));

    sm4_bs256_gcm_encrypt(output,pt_vector,sizeof(pt_vector),rk,
         iv_vector,sizeof(iv_vector),Associated_Data, sizeof(Associated_Data),
         tag, sizeof(tag),ctx);
    printf("ciphertext: \n");
    dump_hex(output,SM4_GCM_TESTS_BYTES);
    printf("tag: \n");
    dump_hex(tag,sizeof(tag));

    printf("SM4-AVX2-bitslice GCM Speed Test.\n");
    uint8_t *plainn = (uint8_t *)malloc(16*(1<<15));
    uint8_t *c = plainn;
    benchmark_sm4_bs_gcm_encrypt(plainn,c,1*16,rk,iv_vector,16,Associated_Data,23,tag,16,T);
    benchmark_sm4_bs_gcm_encrypt(plainn,c,4*16,rk,iv_vector,16,Associated_Data,23,tag,16,T);
    benchmark_sm4_bs_gcm_encrypt(plainn,c,16*16,rk,iv_vector,16,Associated_Data,23,tag,16,T);
    benchmark_sm4_bs_gcm_encrypt(plainn,c,1024,rk,iv_vector,16,Associated_Data,23,tag,16,T);
    benchmark_sm4_bs_gcm_encrypt(plainn,c,8192,rk,iv_vector,16,Associated_Data,23,tag,16,T);
    benchmark_sm4_bs_gcm_encrypt(plainn,c,16384,rk,iv_vector,16,Associated_Data,23,tag,16,T);
    printf("SM4-AVX2-bitslice GCM Speed Test end!\n\n");

    gcm_free(ctx);
    printf("\n");
}

void sm4_bs512_ecb_test()
{
    uint8_t key_vector[16] = {0x01, 0x23, 0x45, 0x67, 0x89, 0xab, 0xcd, 0xef, 0xfe, 0xdc, 0xba, 0x98, 0x76, 0x54, 0x32, 0x10};
    //uint8_t pt_vector[16] =  {0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};
    uint8_t pt_vector[16] =  {0x01, 0x23, 0x45, 0x67, 0x89, 0xab, 0xcd, 0xef, 0xfe, 0xdc, 0xba, 0x98, 0x76, 0x54, 0x32, 0x10};
    uint8_t ct_vector[16] =  {0x68, 0x1e, 0xdf, 0x34, 0xd2, 0x06, 0x96, 0x5e, 0x86, 0xb3, 0xe9, 0x4f, 0x53, 0x6e, 0x42, 0x46};
    uint8_t output[16];
    uint8_t input[16];
    __m512i rk[32][32];

    sm4_bs512_key_schedule(key_vector,rk);
    printf("SM4-AVX512-bitslice ECB 1 block Accuracy Test.:\n");
    sm4_bs512_ecb_encrypt(output,pt_vector,16,rk);
    printf("cipher text: \n");
    dump_hex(output,16);
    if(memcmp(ct_vector,output,16)==0)
        printf("SM4-AVX512-bitslice ECB 1 block encrypt Test passed!\n");
    printf("SM4-AVX512-bitslice ECB 1 block Accuracy Test end:\n\n");

    printf("SM4-AVX512-bitslice ECB Speed Test:\n");
    uint8_t *plainn = (uint8_t *)malloc(16*(1<<15));
    uint8_t *c = plainn;
    benchmark_sm4_bs512_ecb_encrypt(plainn,c,1*16,rk);
    benchmark_sm4_bs512_ecb_encrypt(plainn,c,4*16,rk);
    benchmark_sm4_bs512_ecb_encrypt(plainn,c,256,rk);
    benchmark_sm4_bs512_ecb_encrypt(plainn,c,1024,rk);
    benchmark_sm4_bs512_ecb_encrypt(plainn,c,8192,rk);
    benchmark_sm4_bs512_ecb_encrypt(plainn,c,16384,rk);
    printf("SM4-AVX512-bitslice ECB Speed Test end!\n");
    free(plainn);

}

void sm4_bs512_ctr_test()
{       
    #define SM4_CTR_TESTS_BYTES 64
    printf("SM4-AVX512-bitslice CTR 4 block:\n");
    //test vector from https://tools.ietf.org/id/draft-ribose-cfrg-sm4-09.html#rfc.appendix.A.2.5
    //Example1 Key:
    uint8_t key_vector[16] =
        {0x01, 0x23, 0x45, 0x67, 0x89, 0xAB, 0xCD, 0xEF, 0xFE, 0xDC, 0xBA, 0x98, 0x76, 0x54, 0x32, 0x10};
    uint8_t iv_vector[16]  =
        {0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F};
    uint8_t pt_vector[SM4_CTR_TESTS_BYTES] =
        {0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xBB,0xBB,0xBB,0xBB,0xBB,0xBB,0xBB,0xBB,
            0xCC,0xCC,0xCC,0xCC,0xCC,0xCC,0xCC,0xCC,0xDD,0xDD,0xDD,0xDD,0xDD,0xDD,0xDD,0xDD,
            0xEE,0xEE,0xEE,0xEE,0xEE,0xEE,0xEE,0xEE,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,
            0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xBB,0xBB,0xBB,0xBB,0xBB,0xBB,0xBB,0xBB};
    uint8_t ct_vector[SM4_CTR_TESTS_BYTES] =
       {0xAC, 0x32, 0x36, 0xCB, 0x97, 0x0C, 0xC2, 0x07, 0x91, 0x36, 0x4C, 0x39, 0x5A, 0x13, 0x42, 0xD1,
        0xA3, 0xCB, 0xC1, 0x87, 0x8C, 0x6F, 0x30, 0xCD, 0x07, 0x4C, 0xCE, 0x38, 0x5C, 0xDD, 0x70, 0xC7,
        0xF2, 0x34, 0xBC, 0x0E, 0x24, 0xC1, 0x19, 0x80, 0xFD, 0x12, 0x86, 0x31, 0x0C, 0xE3, 0x7B, 0x92,
        0x6E, 0x02, 0xFC, 0xD0, 0xFA, 0xA0, 0xBA, 0xF3, 0x8B, 0x29, 0x33, 0x85, 0x1D, 0x82, 0x45, 0x14};

    //Example2 Key:
    // uint8_t key_vector[16] =
    //     {0xFE, 0xDC, 0xBA, 0x98, 0x76, 0x54, 0x32, 0x10, 0x01, 0x23, 0x45, 0x67, 0x89, 0xAB, 0xCD, 0xEF };
    // uint8_t iv_vector[16]  =
    //     {0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0A, 0x0B, 0x00, 0x00, 0x00, 0x00};
    // uint8_t key_vector[16] =
    // {   
    //     0x00,0x01,0x00,0x02,0x00,0x03,0x00,0x04,
    //     0x00,0x05,0x00,0x06,0x00,0x07,0x00,0x08
    // };
    // uint8_t iv_vector[16]  =
    //     {0x5c,0x36,0x5c,0x36,0x5c,0x36,0x5c,0x36,0x5c,0x36,0x5c,0x36,0x00, 0x00, 0x00, 0x00};
    // uint8_t pt_vector[SM4_CTR_TESTS_BYTES] = {
    //     0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    //     0x08,0x06,0x00,0x01,0x08,0x00,0x06,0x04,0x00,0x01,0x00,0x03,0x7f,0xff,0xff,0xfe,
    //     0xc0,0xa8,0x14,0x0a,0x00,0x00,0x00,0x00,0x00,0x00,0xc0,0xa8,0x14,0x0d,0x00,0x00,
    //     0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    // };

    uint8_t output[SM4_CTR_TESTS_BYTES];
    uint8_t input[SM4_CTR_TESTS_BYTES];
    uint8_t t[SM4_CTR_TESTS_BYTES];
    __m512i rk[32][32];

    sm4_bs512_key_schedule(key_vector, rk);

    sm4_bs512_ctr_encrypt(output,pt_vector,SM4_CTR_TESTS_BYTES,rk, iv_vector);
    printf("ciphertext: \n");
    dump_hex(output,SM4_CTR_TESTS_BYTES);

    sm4_bs512_ctr_encrypt(t,output,SM4_CTR_TESTS_BYTES,rk, iv_vector);
    printf("plaintext: \n");
    dump_hex(t,SM4_CTR_TESTS_BYTES);

    printf("SM4-AVX512-bitslice CTR Speed Test.\n");
    uint8_t *plainn = (uint8_t *)malloc(16*(1<<15));
    uint8_t *c = plainn;
    benchmark_sm4_bs512_ctr_encrypt(plainn,c,1*16,rk,iv_vector);
    benchmark_sm4_bs512_ctr_encrypt(plainn,c,4*16,rk,iv_vector);
    benchmark_sm4_bs512_ctr_encrypt(plainn,c,16*16,rk,iv_vector);
    benchmark_sm4_bs512_ctr_encrypt(plainn,c,1024,rk,iv_vector);
    benchmark_sm4_bs512_ctr_encrypt(plainn,c,8192,rk,iv_vector);
    benchmark_sm4_bs512_ctr_encrypt(plainn,c,16384,rk,iv_vector);
    printf("SM4-AVX512-bitslice CTR Speed Test end!\n\n");

}

void sm4_bs512_gcm_test()
{       
    // printf("SM4 GCM 256 block:\n");
    // //tect vector from ant finanical 
    // //https://tools.ietf.org/id/draft-yang-tls-tls13-sm-suites-03.html#rfc.appendix.A.1
    // uint8_t iv[12] = {0x00,0x00,0x12,0x34,0x56,0x78,0x00,0x00,0x00,0x00,0xAB,0xCD};
    // uint8_t key[16] = {0x01, 0x23, 0x45, 0x67, 0x89, 0xab, 0xcd, 0xef, 0xfe, 0xdc, 0xba, 0x98, 0x76, 0x54, 0x32, 0x10};
    // uint8_t pt[64] = {0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xBB,0xBB,0xBB,0xBB,0xBB,0xBB,0xBB,0xBB,
    //             0xCC,0xCC,0xCC,0xCC,0xCC,0xCC,0xCC,0xCC,0xDD,0xDD,0xDD,0xDD,0xDD,0xDD,0xDD,0xDD,
    //             0xEE,0xEE,0xEE,0xEE,0xEE,0xEE,0xEE,0xEE,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,
    //             0xEE,0xEE,0xEE,0xEE,0xEE,0xEE,0xEE,0xEE,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA};
    // uint8_t Associated_Data[20] = {0xFE,0xED,0xFA,0xCE,0xDE,0xAD,0xBE,0xEF,0xFE,0xED,0xFA,0xCE,
    //                         0xDE,0xAD,0xBE,0xEF,0xAB,0xAD,0xDA,0xD2};
    // uint8_t ct[64] = {0x48,0xAF,0x93,0x50,0x1F,0xA6,0x2A,0xDB,0xCD,0x41,0x4C,0xCE,0x60,0x34,0xD8,0x95,
    //             0xDD,0xA1,0xBF,0x8F,0x13,0x2F,0x04,0x20,0x98,0x66,0x15,0x72,0xE7,0x48,0x30,0x94,
    //             0xFD,0x12,0xE5,0x18,0xCE,0x06,0x2C,0x98,0xAC,0xEE,0x28,0xD9,0x5D,0xF4,0x41,0x6B,
    //             0xED,0x31,0xA2,0xF0,0x44,0x76,0xC1,0x8B,0xB4,0x0C,0x84,0xA7,0x4B,0x97,0xDC,0x5B};
    // uint8_t au_tag[16] = {0x16,0x84,0x2D,0x4F,0xA1,0x86,0xF5,0x6A,0xB3,0x32,0x56,0x97,0x1F,0xA1,0x10,0xF4};
    #define SM4_GCM_TESTS_BYTES 48
    printf("SM4-AVX512-bitslice GCM 4 block:\n");
    //http://www.gmbz.org.cn/file/2018-01-10/384aaf7c-7530-4290-b314-24264065db9e.pdf
    //tect vector from GB/T 36624--2018:C.5 可鉴别的加密机制5
    // uint8_t key_vector[16] =
    //     {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };
    // uint8_t iv_vector[16]  =
    //     {0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};
    // uint8_t pt_vector[SM4_GCM_TESTS_BYTES] =
    //     {0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    //     0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    //     0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};

    //tect vector from GB/T 0042--2015 三元对等密码安全协议测试规范
    uint8_t key_vector[16] =
    {   
        0x00,0x01,0x00,0x02,0x00,0x03,0x00,0x04,
        0x00,0x05,0x00,0x06,0x00,0x07,0x00,0x08
    };
    uint8_t iv_vector[16]  =
        {0x5c,0x36,0x5c,0x36,0x5c,0x36,0x5c,0x36,0x5c,0x36,0x5c,0x36,0x00, 0x00, 0x00, 0x00};

    uint8_t Associated_Data[]={
        0xff,0xff,0xff,0xff,0xff,0xff,0x00,0x03,0x7f,0xff,0xff,0xfe,0x89,0x2c,0x38,0x00,
        0x00,0x5c,0x36,0x5c,0x36,0x5c,0x36
    };
    uint8_t pt_vector[SM4_GCM_TESTS_BYTES] =
        {0x08,0x06,0x00,0x01,0x08,0x00,0x06,0x04,0x00,0x01,0x00,0x03,0x7f,0xff,0xff,0xfe,
        0xc0,0xa8,0x14,0x0a,0x00,0x00,0x00,0x00,0x00,0x00,0xc0,0xa8,0x14,0x0d,0x00,0x00,
        0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};
    uint8_t ct_vector[SM4_GCM_TESTS_BYTES] =
       {0x0a,0x59,0x91,0xa6,0x70,0xdc,0x0e,0xa2,0x6f,0x84,0xe4,0x55,0xa1,0xc0,0x61,0x47,
        0x8a,0xa0,0x9f,0x2f,0xbe,0x90,0x49,0x46,0x29,0xbc,0x58,0xe7,0x5b,0xe5,0xe9,0x1d,
        0xbc,0x6d,0x21,0x49,0xbc,0x1f,0xba,0xca,0xca,0xa9,0x72,0x2d,0x61,0x0f,0xde,0x1d};
    uint8_t tag[16] = {0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};
    uint8_t T[16][256][16];

    uint8_t output[SM4_GCM_TESTS_BYTES];
    uint8_t input[SM4_GCM_TESTS_BYTES];
    uint8_t t[SM4_GCM_TESTS_BYTES];
    __m512i rk[32][32];

    //sm4_bs256_key_schedule(key_vector,rk);

    gcm_context *ctx = gcm_init();
    sm4_bs512_gcm_init(ctx,key_vector,rk,iv_vector);

    printf("ctx->: \n");
    dump_hex(tag,sizeof(tag));

    sm4_bs512_gcm_encrypt(output,pt_vector,sizeof(pt_vector),rk,
         iv_vector,sizeof(iv_vector),Associated_Data, sizeof(Associated_Data),
         tag, sizeof(tag),ctx);
    printf("ciphertext: \n");
    dump_hex(output,SM4_GCM_TESTS_BYTES);
    printf("tag: \n");
    dump_hex(tag,sizeof(tag));

    printf("SM4-AVX512-bitslice GCM Speed Test.\n");
    uint8_t *plainn = (uint8_t *)malloc(16*(1<<15));
    uint8_t *c = plainn;
    benchmark_sm4_bs512_gcm_encrypt(plainn,c,1*16,rk,iv_vector,16,Associated_Data,23,tag,16,T);
    benchmark_sm4_bs512_gcm_encrypt(plainn,c,4*16,rk,iv_vector,16,Associated_Data,23,tag,16,T);
    benchmark_sm4_bs512_gcm_encrypt(plainn,c,16*16,rk,iv_vector,16,Associated_Data,23,tag,16,T);
    benchmark_sm4_bs512_gcm_encrypt(plainn,c,1024,rk,iv_vector,16,Associated_Data,23,tag,16,T);
    benchmark_sm4_bs512_gcm_encrypt(plainn,c,8192,rk,iv_vector,16,Associated_Data,23,tag,16,T);
    benchmark_sm4_bs512_gcm_encrypt(plainn,c,16384,rk,iv_vector,16,Associated_Data,23,tag,16,T);
    printf("SM4-AVX512-bitslice GCM Speed Test end!\n\n");

    gcm_free(ctx);
}

